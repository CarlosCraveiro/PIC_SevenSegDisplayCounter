#include <pic18fregs.h>
//#include <delay.h>
//#include <stdint.h>

/* FUSES START */
/* Minimum modifications needed. Rest of fuses left as default. */

/* The code generated by SDCC does probably not work when XINST (extended instruction set) is enabled */
#pragma config XINST=OFF

/* Oscillator Selection bits (High-Speed Crystal/Resonator used by USB (INTIO)) */
#pragma config FOSC = HS

// Watchdog timer OFF
// #pragma config WDT = OFF /*This isn't working for some reason*/

// Single-Supply ICSP OFF
/* Standard high-voltage programming must be used to program the device */
#pragma config LVP = OFF
/* FUSES END */

/* Global Variables */
unsigned int counter = 0;  // Stores timer value
unsigned int count_enable = 0;
struct {
    volatile int high;
    volatile int low;
} timer;

unsigned int ssg_lut[10];
/* Global Variables END */

/* Legibility defines */
#define SET_OUTPUT 0b0
#define SET_INPUT 0b1

#define SSG_DISPLAY LATD

#define ISR_RB0_FLAG INTCONbits.INT0IF 
#define ISR_RB1_FLAG INTCON3bits.INT1IF 
#define ISR_TIMER_FLAG INTCONbits.TMR0IF  

/* Seven Segments LUT Configuration */
// Macro for use the LUT
#define DISPLAY(VALUE) (\
    (VALUE >= 0 && VALUE <= 9)? ssg_lut[VALUE] : 0x00 \
)

// Initializes the Seven Segments Display LUT
void configure_ssg_lut(void) {
    ssg_lut[0] = 0x3F;
    ssg_lut[1] = 0x06;
    ssg_lut[2] = 0x5B; 
    ssg_lut[3] = 0x4F;
    ssg_lut[4] = 0x66;
    ssg_lut[5] = 0x6D;
    ssg_lut[6] = 0x7D;
    ssg_lut[7] = 0x07;
    ssg_lut[8] = 0x7F;
    ssg_lut[9] = 0x6F;
}
/* END of SSG LUT Configuration */

void configure_microcontroler(void) {
    //ADCON1 |= 0x0F;  // Set all pins of Port B as Digital Pins
    // Maybe uncomment the line above if some problem appears during the implementation
    INTCON2bits.RBPU = 1; // Pull-ups resistors are enabled by individual port latch values
    
    TRISD = SET_OUTPUT; // Set Port D as output
 
    TRISBbits.RB0 = SET_INPUT; // Set Port RB2 as input
    TRISBbits.RB1 = SET_INPUT; // Set Port RB1 as input    
}

/* Set up Global Interrupts */
void setup_interrupts(void) {
    // General Interrupt configuration
    INTCONbits.GIEH = 1;
    INTCONbits.GIEL = 1;
    RCONbits.IPEN = 1;

    // Enable and priorizes timer interrupts
    INTCONbits.TMR0IF = 0;
    INTCONbits.TMR0IE = 1;
    INTCON2bits.TMR0IP = 1;

    // Enable and priorizes external interrupts
    INTCONbits.INT0IF = 0;
    INTCON3bits.INT1IF = 0;
    INTCON3bits.INT1IP = 1;
    INTCONbits.INT0IE = 1;
    INTCON3bits.INT1IE = 1;

    // Sets interruption to rising edge trigger
    INTCON2bits.INTEDG0 = 1;
    INTCON2bits.INTEDG1 = 1;
}

/* Setups Timer0 */
void setup_timer(void) { 
    T0CONbits.TMR0ON = 0b0; // Timer0 Turn OFF
    T0CONbits.T08BIT = 0b0; // 16 bit counter
    T0CONbits.T0CS = 0b0;   // Internal Instruction Cycle Clock (CLKO)
    T0CONbits.T0SE = 0b0;   // Low->High trigger
    T0CONbits.PSA = 0b0;    // Enable Prescale
    T0CONbits.T0PS = 0b100; // 1:32 Prescale 
}

/* Resets timer with the values provided at `timer` global struct */
void reset_timer() {
    T0CONbits.TMR0ON = 0;   // Turn Off Timer0 for reconfiguration
    TMR0H = timer.high;
    TMR0L = timer.low;
    T0CONbits.TMR0ON = 1;   // Turn On Timer0 with the new values
}

/* Initializes counter, Starts timer and enable count */
void enable_count() {
    counter = 0;
    count_enable = 1;
    reset_timer();
}

/* The main interrupt, code */
void high_isr(void) __interrupt(1) {
    // Checks for timer interrupt
    if (ISR_TIMER_FLAG == 1 && count_enable) {

        if (++counter >= 10) counter = 0; // Increments counter and ensures the loop 0-9
        
        SSG_DISPLAY = DISPLAY(counter); // Displays the counter at SSG Display

        reset_timer();
        
        ISR_TIMER_FLAG = 0; // Clears Interrupt Service Routine Flag
    }

    // Checks RB0 Interrupt
    if (ISR_RB0_FLAG == 1) {
        // Sets period to 1s
        timer.high = 0x0B;
        timer.low = 0xDC;

        if(count_enable == 0) enable_count();
        
        ISR_RB0_FLAG = 0; // Clears Interrupt Service Routine Flag
    }

    // Checks RB1 Interrupt
    if (ISR_RB1_FLAG == 1) { 
        // Sets period to 0.25s
        timer.high = 0xC2;
        timer.low = 0xF7;

        if(count_enable == 0) enable_count();

        ISR_RB1_FLAG = 0; // Clears Interrupt Service Routine Flag
    }
}

void main() {
    count_enable = 0;
    /* Configures Microcontroler and its Ports */
    configure_microcontroler();

    /* Setup the interrupts and its configurations*/
    setup_interrupts();

    /* Setup Timer0 */
    setup_timer();
    
    /* Initializes the seven segments LUT */
    configure_ssg_lut();

    /* Set the initial value of the display to 0 */
    SSG_DISPLAY = DISPLAY(0);

    /* Main Loop */
    while(1) {
    // Clears the Watchdog since the flag to disable watchdog is not working on SDCC
        __asm
            CLRWDT 
        __endasm;
    }
}
