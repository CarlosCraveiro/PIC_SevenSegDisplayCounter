#include <pic18fregs.h>

/* FUSES START */
/* Minimum modifications needed. Rest of fuses left as default. */

/* The code generated by SDCC does probably not work when XINST (extended instruction set) is enabled */
#pragma config XINST=OFF

/* Oscillator Selection bits (High-Speed Crystal/Resonator used by USB (INTIO)) */
#pragma config FOSC = HS

// Watchdog timer OFF
// #pragma config WDT = OFF /*This isn't working for some reason*/

// Single-Supply ICSP OFF
/* Standard high-voltage programming must be used to program the device */
#pragma config LVP = OFF
/* FUSES END */

/* Global Variables */
unsigned int counter = 0;  // Stores timer value
unsigned int count_enable = 0;
struct {
    volatile int high;
    volatile int low;
} timer;

unsigned int ssg_lut[10];
/* Global Variables END */

/* Legibility defines */
#define SET_OUTPUT 0b0
#define SET_INPUT 0b1

#define SSG_DISPLAY LATD

#define ISR_RB0_FLAG INTCONbits.INT0IF 
#define ISR_RB1_FLAG INTCON3bits.INT1IF 
#define ISR_TIMER_FLAG INTCONbits.TMR0IF  

/* Seven Segments LUT Configuration */
// Macro for use the LUT
#define DISPLAY(VALUE) (\
    (VALUE >= 0 && VALUE <= 9)? ssg_lut[VALUE] : 0x00 \
)

/* Initializes the Seven Segments Display LUT */
/* Pattern used considering a Common Cathode SSG Display */
void configure_ssg_lut(void) {
    ssg_lut[0] = 0x3F;
    ssg_lut[1] = 0x06;
    ssg_lut[2] = 0x5B; 
    ssg_lut[3] = 0x4F;
    ssg_lut[4] = 0x66;
    ssg_lut[5] = 0x6D;
    ssg_lut[6] = 0x7D;
    ssg_lut[7] = 0x07;
    ssg_lut[8] = 0x7F;
    ssg_lut[9] = 0x6F;
}
/* END of SSG LUT Configuration */

void configure_microcontroler(void) {
    //ADCON1 |= 0x0F;  // Set all pins of Port B as Digital Pins
    // Maybe uncomment the line above if some problem appears during the implementation
    INTCON2bits.RBPU = 1; // Pull-ups resistors are enabled by individual port latch values
    
    TRISD = SET_OUTPUT; // Set Port D as output
 
    TRISBbits.RB0 = SET_INPUT; // Set Port RB2 as input
    TRISBbits.RB1 = SET_INPUT; // Set Port RB1 as input    
}

/* Set up Global Interrupts */
void setup_interrupts(void) {
    /* General Interrupt configuration */
    INTCONbits.GIEH = 1;    // Enables High Priority Interrupts
    INTCONbits.GIEL = 1;    // Enables Low Priority Interrupts
    RCONbits.IPEN = 1;      // Enable priority levels for interrupts (handle both high and low)

    /* Enable and priorizes timer interrupts */
    ISR_TIMER_FLAG = 0;     // Clears Interrupt Timer Flag 
    INTCONbits.TMR0IE = 1;  // Enable Timer0 Interrupt
    INTCON2bits.TMR0IP = 1; // Set Timer0 Interrupt as a High Priority Interrupt

    /* Enable and priorizes external interrupts */
    ISR_RB0_FLAG = 0;       // Clears Interrupt for RB0(INT0) Flag
    ISR_RB1_FLAG = 0;       // Clears Interrupt for RB1(INT1) Flag
    INTCON3bits.INT1IP = 0; // Set Priority INT1 to high
                            // Priority of INT0 is immutably High 
    INTCONbits.INT0IE = 1;  // Enable INT0 as External Interrupt
    INTCON3bits.INT1IE = 1; // Enable INT1 as External Interrupt

    // Sets interruption to rising edge trigger
    INTCON2bits.INTEDG0 = 1;// rising edge for INT0
    INTCON2bits.INTEDG1 = 1;// rising edge for INT1
}

/* Setups Timer0 */
void setup_timer(void) { 
    T0CONbits.TMR0ON = 0b0; // Timer0 Turn OFF
    T0CONbits.T08BIT = 0b0; // 16 bit counter
    T0CONbits.T0CS = 0b0;   // Internal Instruction Cycle Clock (CLKO)
    T0CONbits.T0SE = 0b0;   // Low->High trigger
    T0CONbits.PSA = 0b0;    // Enable Prescale
    T0CONbits.T0PS = 0b100; // 1:32 Prescale 
}

/* Resets timer with the values provided at `timer` global struct */
void reset_timer() {
    T0CONbits.TMR0ON = 0;   // Turn Off Timer0 for reconfiguration
    TMR0H = timer.high;
    TMR0L = timer.low;
    T0CONbits.TMR0ON = 1;   // Turn On Timer0 with the new values
}

/* Initializes counter, Starts timer and enable count */
void enable_count() {
    counter = 0;
    count_enable = 1;
    reset_timer();
}

/* High Interrupt Service Routine (Deals with INT0 and Timer0 Interrupt) */
void high_isr(void) __interrupt(1) {
    // Checks for timer interrupt
    if (count_enable && ISR_TIMER_FLAG == 1) {

        if (++counter >= 10) counter = 0; // Increments counter and ensures the loop 0-9
        
        SSG_DISPLAY = DISPLAY(counter); // Displays the counter at SSG Display

        reset_timer();
        
        ISR_TIMER_FLAG = 0; // Clears Interrupt Service Routine Flag
    }
    
    // Checks RB0 Interrupt
    if (ISR_RB0_FLAG == 1) {
        // Sets period to 1s
        timer.high = 0x0B;
        timer.low = 0xDC;

        if(count_enable == 0) enable_count();
        
        ISR_RB0_FLAG = 0; // Clears Interrupt Service Routine Flag
    }
}

/* Low Interrupt Service Routine (Deals with INT1) */
void low_isr(void) __interrupt(2) {
    // Checks RB1 Interrupt
    if (ISR_RB1_FLAG == 1) { 
        // Sets period to 0.25s
        timer.high = 0xC2;
        timer.low = 0xF7;

        if(count_enable == 0) enable_count();

        ISR_RB1_FLAG = 0; // Clears Interrupt Service Routine Flag
    }
}

void main() {
    count_enable = 0;
    /* Configures Microcontroler and its Ports */
    configure_microcontroler();

    /* Setup the interrupts and its configurations*/
    setup_interrupts();

    /* Setup Timer0 */
    setup_timer();
    
    /* Initializes the seven segments LUT */
    configure_ssg_lut();

    /* Set the initial value of the display to 0 */
    SSG_DISPLAY = DISPLAY(0);

    /* Main Loop */
    while(1) {
        __asm
            CLRWDT 
        __endasm;
    /* Clears the Watchdog since the flag to disable watchdog is not working on SDCC */
    }
}
